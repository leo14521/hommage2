{"version":3,"sources":["../../../../node_modules/next/dist/esm/build/templates/app-page.js%3Fpage%3D/signature/juvegen/page"],"sourcesContent":["const __TURBOPACK__layout__$23$0__ = () => require(\"MODULE_0\");\n\nconst __TURBOPACK__not$2d$found__$23$1__ = () => require(\"MODULE_1\");\n\nconst __TURBOPACK__forbidden__$23$2__ = () => require(\"MODULE_2\");\n\nconst __TURBOPACK__unauthorized__$23$3__ = () => require(\"MODULE_3\");\n\nconst __TURBOPACK__global$2d$error__$23$4__ = () => require(\"MODULE_4\");\n\nconst __TURBOPACK__page__$23$5__ = () => require(\"MODULE_5\");\n\nimport { AppPageRouteModule } from \"next/dist/esm/server/route-modules/app-page/module.compiled\" with {\n    'turbopack-transition': 'next-ssr'\n};\nimport { RouteKind } from \"next/dist/esm/server/route-kind\" with {\n    'turbopack-transition': 'next-server-utility'\n};\nimport { getRevalidateReason } from \"next/dist/esm/server/instrumentation/utils\";\nimport { getTracer, SpanKind } from \"next/dist/esm/server/lib/trace/tracer\";\nimport { addRequestMeta, getRequestMeta, setRequestMeta } from \"next/dist/esm/server/request-meta\";\nimport { BaseServerSpan } from \"next/dist/esm/server/lib/trace/constants\";\nimport { interopDefault } from \"next/dist/esm/server/app-render/interop-default\";\nimport { stripFlightHeaders } from \"next/dist/esm/server/app-render/strip-flight-headers\";\nimport { NodeNextRequest, NodeNextResponse } from \"next/dist/esm/server/base-http/node\";\nimport { checkIsAppPPREnabled } from \"next/dist/esm/server/lib/experimental/ppr\";\nimport { getFallbackRouteParams, createOpaqueFallbackRouteParams } from \"next/dist/esm/server/request/fallback-params\";\nimport { setManifestsSingleton } from \"next/dist/esm/server/app-render/manifests-singleton\";\nimport { isHtmlBotRequest, shouldServeStreamingMetadata } from \"next/dist/esm/server/lib/streaming-metadata\";\nimport { normalizeAppPath } from \"next/dist/esm/shared/lib/router/utils/app-paths\";\nimport { getIsPossibleServerAction } from \"next/dist/esm/server/lib/server-action-request-meta\";\nimport { RSC_HEADER, NEXT_ROUTER_PREFETCH_HEADER, NEXT_INSTANT_PREFETCH_HEADER, NEXT_INSTANT_TEST_COOKIE, NEXT_IS_PRERENDER_HEADER, NEXT_DID_POSTPONE_HEADER, RSC_CONTENT_TYPE_HEADER } from \"next/dist/esm/client/components/app-router-headers\";\nimport { getBotType, isBot } from \"next/dist/esm/shared/lib/router/utils/is-bot\";\nimport { CachedRouteKind, IncrementalCacheKind } from \"next/dist/esm/server/response-cache\";\nimport { FallbackMode, parseFallbackField } from \"next/dist/esm/lib/fallback\";\nimport RenderResult from \"next/dist/esm/server/render-result\";\nimport { CACHE_ONE_YEAR_SECONDS, HTML_CONTENT_TYPE_HEADER, NEXT_CACHE_TAGS_HEADER, NEXT_NAV_DEPLOYMENT_ID_HEADER, NEXT_RESUME_HEADER, NEXT_RESUME_STATE_LENGTH_HEADER } from \"next/dist/esm/lib/constants\";\nimport { ENCODED_TAGS } from \"next/dist/esm/server/stream-utils/encoded-tags\";\nimport { sendRenderResult } from \"next/dist/esm/server/send-payload\";\nimport { NoFallbackError } from \"next/dist/esm/shared/lib/no-fallback-error.external\";\nimport { DEFAULT_MAX_POSTPONED_STATE_SIZE, parseMaxPostponedStateSize } from \"next/dist/esm/shared/lib/size-limit\";\n// We inject the tree and pages here so that we can use them in the route\n// module.\nconst tree = [\"\", {\n\"children\": [\"signature\", {\n\"children\": [\"juvegen\", {\n\"children\": [\"__PAGE__\", {\n}, {\n  metadata: {  },  \"page\": [__TURBOPACK__page__$23$5__, \"[project]/src/app/signature/juvegen/page.tsx\"],\n}, []],\n}, {\n  metadata: {  },}, []],\n}, {\n  metadata: {  },}, []],\n}, {\n  \"layout\": [__TURBOPACK__layout__$23$0__, \"[project]/src/app/layout.tsx\"],\n  \"not-found\": [__TURBOPACK__not$2d$found__$23$1__, \"[project]/node_modules/next/dist/client/components/builtin/not-found.js\"],\n  \"forbidden\": [__TURBOPACK__forbidden__$23$2__, \"[project]/node_modules/next/dist/client/components/builtin/forbidden.js\"],\n  \"unauthorized\": [__TURBOPACK__unauthorized__$23$3__, \"[project]/node_modules/next/dist/client/components/builtin/unauthorized.js\"],\n  \"global-error\": [__TURBOPACK__global$2d$error__$23$4__, \"[project]/node_modules/next/dist/client/components/builtin/global-error.js\"],\n}, []]\nconst __next_app_require__ = __turbopack_context__.r.bind(__turbopack_context__)\nconst __next_app_load_chunk__ = __turbopack_context__.l.bind(__turbopack_context__)\nexport const __next_app__ = {\n    require: __next_app_require__,\n    loadChunk: __next_app_load_chunk__\n};\nimport * as entryBase from \"next/dist/esm/server/app-render/entry-base\" with {\n    'turbopack-transition': 'next-server-utility'\n};\nimport { RedirectStatusCode } from \"next/dist/esm/client/components/redirect-status-code\";\nimport { InvariantError } from \"next/dist/esm/shared/lib/invariant-error\";\nimport { scheduleOnNextTick } from \"next/dist/esm/lib/scheduler\";\nimport { isInterceptionRouteAppPath } from \"next/dist/esm/shared/lib/router/utils/interception-routes\";\nexport * from \"next/dist/esm/server/app-render/entry-base\" with {\n    'turbopack-transition': 'next-server-utility'\n};\n// Create and export the route module that will be consumed.\nexport const routeModule = new AppPageRouteModule({\n    definition: {\n        kind: RouteKind.APP_PAGE,\n        page: \"/signature/juvegen/page\",\n        pathname: \"/signature/juvegen\",\n        // The following aren't used in production.\n        bundlePath: '',\n        filename: '',\n        appPaths: []\n    },\n    userland: {\n        loaderTree: tree\n    },\n    distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n    relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || ''\n});\nexport async function handler(req, res, ctx) {\n    var _this, _prerenderManifest_routes_resolvedPathname;\n    if (ctx.requestMeta) {\n        setRequestMeta(req, ctx.requestMeta);\n    }\n    if (routeModule.isDev) {\n        addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint());\n    }\n    const isMinimalMode = Boolean(getRequestMeta(req, 'minimalMode'));\n    let srcPage = \"/signature/juvegen/page\";\n    // turbopack doesn't normalize `/index` in the page name\n    // so we need to to process dynamic routes properly\n    // TODO: fix turbopack providing differing value from webpack\n    if (process.env.TURBOPACK) {\n        srcPage = srcPage.replace(/\\/index$/, '') || '/';\n    } else if (srcPage === '/index') {\n        // we always normalize /index specifically\n        srcPage = '/';\n    }\n    const multiZoneDraftMode = process.env.__NEXT_MULTI_ZONE_DRAFT_MODE;\n    const prepareResult = await routeModule.prepare(req, res, {\n        srcPage,\n        multiZoneDraftMode\n    });\n    if (!prepareResult) {\n        res.statusCode = 400;\n        res.end('Bad Request');\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n        return null;\n    }\n    const { buildId, query, params, pageIsDynamic, buildManifest, nextFontManifest, reactLoadableManifest, serverActionsManifest, clientReferenceManifest, subresourceIntegrityManifest, prerenderManifest, isDraftMode, resolvedPathname, revalidateOnlyGenerated, routerServerContext, nextConfig, parsedUrl, interceptionRoutePatterns, deploymentId } = prepareResult;\n    const normalizedSrcPage = normalizeAppPath(srcPage);\n    let { isOnDemandRevalidate } = prepareResult;\n    // We use the resolvedPathname instead of the parsedUrl.pathname because it\n    // is not rewritten as resolvedPathname is. This will ensure that the correct\n    // prerender info is used instead of using the original pathname as the\n    // source. If however PPR is enabled and cacheComponents is disabled, we\n    // treat the pathname as dynamic. Currently, there's a bug in the PPR\n    // implementation that incorrectly leaves %%drp placeholders in the output of\n    // parallel routes. This is addressed with cacheComponents.\n    const prerenderInfo = nextConfig.experimental.ppr && !nextConfig.cacheComponents && isInterceptionRouteAppPath(resolvedPathname) ? null : routeModule.match(resolvedPathname, prerenderManifest);\n    const isPrerendered = !!prerenderManifest.routes[resolvedPathname];\n    const userAgent = req.headers['user-agent'] || '';\n    const botType = getBotType(userAgent);\n    const isHtmlBot = isHtmlBotRequest(req);\n    /**\n   * If true, this indicates that the request being made is for an app\n   * prefetch request.\n   */ const isPrefetchRSCRequest = getRequestMeta(req, 'isPrefetchRSCRequest') ?? req.headers[NEXT_ROUTER_PREFETCH_HEADER] === '1' // exclude runtime prefetches, which use '2'\n    ;\n    // NOTE: Don't delete headers[RSC] yet, it still needs to be used in renderToHTML later\n    const isRSCRequest = getRequestMeta(req, 'isRSCRequest') ?? Boolean(req.headers[RSC_HEADER]);\n    const isPossibleServerAction = getIsPossibleServerAction(req);\n    /**\n   * If the route being rendered is an app page, and the ppr feature has been\n   * enabled, then the given route _could_ support PPR.\n   */ const couldSupportPPR = checkIsAppPPREnabled(nextConfig.experimental.ppr);\n    // Stash postponed state for server actions when in minimal mode.\n    // We extract it here so the RDC is available for the re-render after the action completes.\n    const resumeStateLengthHeader = req.headers[NEXT_RESUME_STATE_LENGTH_HEADER];\n    if (!getRequestMeta(req, 'postponed') && isMinimalMode && couldSupportPPR && isPossibleServerAction && resumeStateLengthHeader && typeof resumeStateLengthHeader === 'string') {\n        const stateLength = parseInt(resumeStateLengthHeader, 10);\n        const maxPostponedStateSize = nextConfig.experimental.maxPostponedStateSize ?? DEFAULT_MAX_POSTPONED_STATE_SIZE;\n        const maxPostponedStateSizeBytes = parseMaxPostponedStateSize(nextConfig.experimental.maxPostponedStateSize);\n        if (!isNaN(stateLength) && stateLength > 0) {\n            var _nextConfig_experimental_serverActions;\n            if (maxPostponedStateSizeBytes === undefined || stateLength > maxPostponedStateSizeBytes) {\n                res.statusCode = 413;\n                res.end(`Postponed state exceeded ${maxPostponedStateSize} limit. ` + `To configure the limit, see: https://nextjs.org/docs/app/api-reference/config/next-config-js/max-postponed-state-size`);\n                ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n                return null;\n            }\n            // Calculate max total body size to prevent buffering excessively large\n            // payloads before the action handler checks. We use stateLength (not\n            // maxPostponedStateSizeBytes) so the postponed state doesn't eat into\n            // the action body budget - it's already validated above.\n            const defaultActionBodySizeLimit = '1 MB';\n            const actionBodySizeLimit = ((_nextConfig_experimental_serverActions = nextConfig.experimental.serverActions) == null ? void 0 : _nextConfig_experimental_serverActions.bodySizeLimit) ?? defaultActionBodySizeLimit;\n            const actionBodySizeLimitBytes = actionBodySizeLimit !== defaultActionBodySizeLimit ? require('next/dist/compiled/bytes').parse(actionBodySizeLimit) : 1024 * 1024 // 1 MB\n            ;\n            const maxTotalBodySize = stateLength + actionBodySizeLimitBytes;\n            // Read the entire body, checking size as we go.\n            const bodyChunks = [];\n            let size = 0;\n            for await (const chunk of req){\n                const buffer = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);\n                size += buffer.byteLength;\n                if (size > maxTotalBodySize) {\n                    res.statusCode = 413;\n                    res.end(`Request body exceeded limit. ` + `To configure the body size limit for Server Actions, see: https://nextjs.org/docs/app/api-reference/next-config-js/serverActions#bodysizelimit`);\n                    ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n                    return null;\n                }\n                bodyChunks.push(buffer);\n            }\n            const fullBody = Buffer.concat(bodyChunks);\n            if (fullBody.length >= stateLength) {\n                // Extract postponed state from the beginning\n                const postponedState = fullBody.subarray(0, stateLength).toString('utf8');\n                addRequestMeta(req, 'postponed', postponedState);\n                // Store the remaining action body for the action handler\n                const actionBody = fullBody.subarray(stateLength);\n                addRequestMeta(req, 'actionBody', actionBody);\n            } else {\n                throw Object.defineProperty(new Error(`invariant: expected ${stateLength} bytes of postponed state but only received ${fullBody.length} bytes`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E979\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n        }\n    }\n    if (!getRequestMeta(req, 'postponed') && couldSupportPPR && req.headers[NEXT_RESUME_HEADER] === '1' && req.method === 'POST') {\n        // Decode the postponed state from the request body, it will come as\n        // an array of buffers, so collect them and then concat them to form\n        // the string.\n        const body = [];\n        for await (const chunk of req){\n            body.push(chunk);\n        }\n        const postponed = Buffer.concat(body).toString('utf8');\n        addRequestMeta(req, 'postponed', postponed);\n    }\n    // When enabled, this will allow the use of the `?__nextppronly` query to\n    // enable debugging of the static shell.\n    const hasDebugStaticShellQuery = process.env.__NEXT_EXPERIMENTAL_STATIC_SHELL_DEBUGGING === '1' && typeof query.__nextppronly !== 'undefined' && couldSupportPPR;\n    // When enabled, this will allow the use of the `?__nextppronly` query\n    // to enable debugging of the fallback shell.\n    const hasDebugFallbackShellQuery = hasDebugStaticShellQuery && query.__nextppronly === 'fallback';\n    // Whether the testing API is exposed (dev mode or explicit flag)\n    const exposeTestingApi = routeModule.isDev === true || nextConfig.experimental.exposeTestingApiInProductionBuild === true;\n    // Enable the Instant Navigation Testing API. Renders only the prefetched\n    // portion of the page, excluding dynamic content. This allows tests to\n    // assert on the prefetched UI state deterministically.\n    // - Header: Used for client-side navigations where we can set request headers\n    // - Cookie: Used for MPA navigations (page reload, full page load) where we\n    //   can't set request headers. Only applies to document requests (no RSC\n    //   header) - RSC requests should proceed normally even during a locked scope,\n    //   with blocking happening on the client side.\n    const isInstantNavigationTest = exposeTestingApi && couldSupportPPR && (req.headers[NEXT_INSTANT_PREFETCH_HEADER] === '1' || req.headers[RSC_HEADER] === undefined && typeof req.headers.cookie === 'string' && req.headers.cookie.includes(NEXT_INSTANT_TEST_COOKIE + '='));\n    // This page supports PPR if it is marked as being `PARTIALLY_STATIC` in the\n    // prerender manifest and this is an app page.\n    const isRoutePPREnabled = couldSupportPPR && (((_this = prerenderManifest.routes[normalizedSrcPage] ?? prerenderManifest.dynamicRoutes[normalizedSrcPage]) == null ? void 0 : _this.renderingMode) === 'PARTIALLY_STATIC' || // Ideally we'd want to check the appConfig to see if this page has PPR\n    // enabled or not, but that would require plumbing the appConfig through\n    // to the server during development. We assume that the page supports it\n    // but only during development or when the testing API is exposed.\n    (hasDebugStaticShellQuery || isInstantNavigationTest) && (exposeTestingApi || (routerServerContext == null ? void 0 : routerServerContext.experimentalTestProxy) === true));\n    const isDebugStaticShell = (hasDebugStaticShellQuery || isInstantNavigationTest) && isRoutePPREnabled;\n    // We should enable debugging dynamic accesses when the static shell\n    // debugging has been enabled and we're also in development mode.\n    const isDebugDynamicAccesses = isDebugStaticShell && routeModule.isDev === true;\n    const isDebugFallbackShell = hasDebugFallbackShellQuery && isRoutePPREnabled;\n    // If we're in minimal mode, then try to get the postponed information from\n    // the request metadata. If available, use it for resuming the postponed\n    // render.\n    const minimalPostponed = isRoutePPREnabled ? getRequestMeta(req, 'postponed') : undefined;\n    // If PPR is enabled, and this is a RSC request (but not a prefetch), then\n    // we can use this fact to only generate the flight data for the request\n    // because we can't cache the HTML (as it's also dynamic).\n    const staticPrefetchDataRoute = (_prerenderManifest_routes_resolvedPathname = prerenderManifest.routes[resolvedPathname]) == null ? void 0 : _prerenderManifest_routes_resolvedPathname.prefetchDataRoute;\n    let isDynamicRSCRequest = isRoutePPREnabled && isRSCRequest && !isPrefetchRSCRequest && // If generated at build time, treat the RSC request as static\n    // so we can serve the prebuilt .rsc without a dynamic render.\n    // Only do this for routes that have a concrete prefetchDataRoute.\n    !staticPrefetchDataRoute;\n    // During a PPR revalidation, the RSC request is not dynamic if we do not have the postponed data.\n    // We only attach the postponed data during a resume. If there's no postponed data, then it must be a revalidation.\n    // This is to ensure that we don't bypass the cache during a revalidation.\n    if (isMinimalMode) {\n        isDynamicRSCRequest = isDynamicRSCRequest && !!minimalPostponed;\n    }\n    // Need to read this before it's stripped by stripFlightHeaders. We don't\n    // need to transfer it to the request meta because it's only read\n    // within this function; the static segment data should have already been\n    // generated, so we will always either return a static response or a 404.\n    const segmentPrefetchHeader = getRequestMeta(req, 'segmentPrefetchRSCRequest');\n    // TODO: investigate existing bug with shouldServeStreamingMetadata always\n    // being true for a revalidate due to modifying the base-server this.renderOpts\n    // when fixing this to correct logic it causes hydration issue since we set\n    // serveStreamingMetadata to true during export\n    const serveStreamingMetadata = botType && isRoutePPREnabled ? false : !userAgent ? true : shouldServeStreamingMetadata(userAgent, nextConfig.htmlLimitedBots);\n    const isSSG = Boolean((prerenderInfo || isPrerendered || prerenderManifest.routes[normalizedSrcPage]) && // If this is a bot request and PPR is enabled, then we don't want\n    // to serve a static response. This applies to both DOM bots (like Googlebot)\n    // and HTML-limited bots.\n    !(botType && isRoutePPREnabled));\n    // When a page supports cacheComponents, we can support RDC for Navigations\n    const supportsRDCForNavigations = isRoutePPREnabled && nextConfig.cacheComponents === true;\n    // In development, we always want to generate dynamic HTML.\n    const supportsDynamicResponse = // If we're in development, we always support dynamic HTML, unless it's\n    // a data request, in which case we only produce static HTML.\n    routeModule.isDev === true || // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isSSG || // If this request has provided postponed data, it supports dynamic\n    // HTML.\n    typeof minimalPostponed === 'string' || // If this handler supports onCacheEntryV2, then we can only support\n    // dynamic responses if it's a dynamic RSC request and not in minimal mode. If it\n    // doesn't support it we must fallback to the default behavior.\n    (supportsRDCForNavigations && getRequestMeta(req, 'onCacheEntryV2') ? // which will generate the RDC for the route. When resuming a Dynamic\n    // RSC request, we'll pass the minimal postponed data to the render\n    // which will trigger the `supportsDynamicResponse` to be true.\n    isDynamicRSCRequest && !isMinimalMode : isDynamicRSCRequest);\n    // When bots request PPR page, perform the full dynamic rendering.\n    // This applies to both DOM bots (like Googlebot) and HTML-limited bots.\n    const shouldWaitOnAllReady = Boolean(botType) && isRoutePPREnabled;\n    let ssgCacheKey = null;\n    if (!isDraftMode && isSSG && !supportsDynamicResponse && !isPossibleServerAction && !minimalPostponed && !isDynamicRSCRequest) {\n        ssgCacheKey = resolvedPathname;\n    }\n    // the staticPathKey differs from ssgCacheKey since\n    // ssgCacheKey is null in dev since we're always in \"dynamic\"\n    // mode in dev to bypass the cache, but we still need to honor\n    // dynamicParams = false in dev mode\n    let staticPathKey = ssgCacheKey;\n    if (!staticPathKey && routeModule.isDev) {\n        staticPathKey = resolvedPathname;\n    }\n    // If this is a request for an app path that should be statically generated\n    // and we aren't in the edge runtime, strip the flight headers so it will\n    // generate the static response.\n    if (!routeModule.isDev && !isDraftMode && isSSG && isRSCRequest && !isDynamicRSCRequest) {\n        stripFlightHeaders(req.headers);\n    }\n    const ComponentMod = {\n        ...entryBase,\n        tree,\n        handler,\n        routeModule,\n        __next_app__\n    };\n    // Before rendering (which initializes component tree modules), we have to\n    // set the reference manifests to our global store so Server Action's\n    // encryption util can access to them at the top level of the page module.\n    if (serverActionsManifest && clientReferenceManifest) {\n        setManifestsSingleton({\n            page: srcPage,\n            clientReferenceManifest,\n            serverActionsManifest\n        });\n    }\n    const method = req.method || 'GET';\n    const tracer = getTracer();\n    const activeSpan = tracer.getActiveScopeSpan();\n    const render404 = async ()=>{\n        // TODO: should route-module itself handle rendering the 404\n        if (routerServerContext == null ? void 0 : routerServerContext.render404) {\n            await routerServerContext.render404(req, res, parsedUrl, false);\n        } else {\n            res.end('This page could not be found');\n        }\n        return null;\n    };\n    try {\n        const varyHeader = routeModule.getVaryHeader(resolvedPathname, interceptionRoutePatterns);\n        res.setHeader('Vary', varyHeader);\n        const invokeRouteModule = async (span, context)=>{\n            const nextReq = new NodeNextRequest(req);\n            const nextRes = new NodeNextResponse(res);\n            return routeModule.render(nextReq, nextRes, context).finally(()=>{\n                if (!span) return;\n                span.setAttributes({\n                    'http.status_code': res.statusCode,\n                    'next.rsc': false\n                });\n                const rootSpanAttributes = tracer.getRootSpanAttributes();\n                // We were unable to get attributes, probably OTEL is not enabled\n                if (!rootSpanAttributes) {\n                    return;\n                }\n                if (rootSpanAttributes.get('next.span_type') !== BaseServerSpan.handleRequest) {\n                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\n                    return;\n                }\n                const route = rootSpanAttributes.get('next.route');\n                if (route) {\n                    const name = `${method} ${route}`;\n                    span.setAttributes({\n                        'next.route': route,\n                        'http.route': route,\n                        'next.span_name': name\n                    });\n                    span.updateName(name);\n                } else {\n                    span.updateName(`${method} ${srcPage}`);\n                }\n            });\n        };\n        const incrementalCache = getRequestMeta(req, 'incrementalCache') || await routeModule.getIncrementalCache(req, nextConfig, prerenderManifest, isMinimalMode);\n        incrementalCache == null ? void 0 : incrementalCache.resetRequestCache();\n        globalThis.__incrementalCache = incrementalCache;\n        const doRender = async ({ span, postponed, fallbackRouteParams, forceStaticRender })=>{\n            const context = {\n                query,\n                params,\n                page: normalizedSrcPage,\n                sharedContext: {\n                    buildId,\n                    deploymentId\n                },\n                serverComponentsHmrCache: getRequestMeta(req, 'serverComponentsHmrCache'),\n                fallbackRouteParams,\n                renderOpts: {\n                    App: ()=>null,\n                    Document: ()=>null,\n                    pageConfig: {},\n                    ComponentMod,\n                    Component: interopDefault(ComponentMod),\n                    params,\n                    routeModule,\n                    page: srcPage,\n                    postponed,\n                    shouldWaitOnAllReady,\n                    serveStreamingMetadata,\n                    supportsDynamicResponse: typeof postponed === 'string' || supportsDynamicResponse,\n                    buildManifest,\n                    nextFontManifest,\n                    reactLoadableManifest,\n                    subresourceIntegrityManifest,\n                    setCacheStatus: routerServerContext == null ? void 0 : routerServerContext.setCacheStatus,\n                    setIsrStatus: routerServerContext == null ? void 0 : routerServerContext.setIsrStatus,\n                    setReactDebugChannel: routerServerContext == null ? void 0 : routerServerContext.setReactDebugChannel,\n                    sendErrorsToBrowser: routerServerContext == null ? void 0 : routerServerContext.sendErrorsToBrowser,\n                    dir: process.env.NEXT_RUNTIME === 'nodejs' ? require('path').join(/* turbopackIgnore: true */ process.cwd(), routeModule.relativeProjectDir) : `${process.cwd()}/${routeModule.relativeProjectDir}`,\n                    isDraftMode,\n                    botType,\n                    isOnDemandRevalidate,\n                    isPossibleServerAction,\n                    assetPrefix: nextConfig.assetPrefix,\n                    nextConfigOutput: nextConfig.output,\n                    crossOrigin: nextConfig.crossOrigin,\n                    trailingSlash: nextConfig.trailingSlash,\n                    images: nextConfig.images,\n                    previewProps: prerenderManifest.preview,\n                    enableTainting: nextConfig.experimental.taint,\n                    htmlLimitedBots: nextConfig.htmlLimitedBots,\n                    reactMaxHeadersLength: nextConfig.reactMaxHeadersLength,\n                    multiZoneDraftMode,\n                    incrementalCache,\n                    cacheLifeProfiles: nextConfig.cacheLife,\n                    basePath: nextConfig.basePath,\n                    serverActions: nextConfig.experimental.serverActions,\n                    logServerFunctions: typeof nextConfig.logging === 'object' && Boolean(nextConfig.logging.serverFunctions),\n                    ...isDebugStaticShell || isDebugDynamicAccesses || isDebugFallbackShell ? {\n                        isBuildTimePrerendering: true,\n                        supportsDynamicResponse: false,\n                        isStaticGeneration: true,\n                        isDebugDynamicAccesses: isDebugDynamicAccesses\n                    } : {},\n                    cacheComponents: Boolean(nextConfig.cacheComponents),\n                    experimental: {\n                        isRoutePPREnabled,\n                        expireTime: nextConfig.expireTime,\n                        staleTimes: nextConfig.experimental.staleTimes,\n                        dynamicOnHover: Boolean(nextConfig.experimental.dynamicOnHover),\n                        optimisticRouting: Boolean(nextConfig.experimental.optimisticRouting),\n                        inlineCss: Boolean(nextConfig.experimental.inlineCss),\n                        authInterrupts: Boolean(nextConfig.experimental.authInterrupts),\n                        clientTraceMetadata: nextConfig.experimental.clientTraceMetadata || [],\n                        clientParamParsingOrigins: nextConfig.experimental.clientParamParsingOrigins,\n                        maxPostponedStateSizeBytes: parseMaxPostponedStateSize(nextConfig.experimental.maxPostponedStateSize)\n                    },\n                    waitUntil: ctx.waitUntil,\n                    onClose: (cb)=>{\n                        res.on('close', cb);\n                    },\n                    onAfterTaskError: ()=>{},\n                    onInstrumentationRequestError: (error, _request, errorContext, silenceLog)=>routeModule.onRequestError(req, error, errorContext, silenceLog, routerServerContext),\n                    err: getRequestMeta(req, 'invokeError'),\n                    dev: routeModule.isDev\n                }\n            };\n            // When we're revalidating in the background, we should not allow dynamic\n            // responses.\n            if (forceStaticRender) {\n                context.renderOpts.supportsDynamicResponse = false;\n            }\n            const result = await invokeRouteModule(span, context);\n            const { metadata } = result;\n            const { cacheControl, headers = {}, // Add any fetch tags that were on the page to the response headers.\n            fetchTags: cacheTags, fetchMetrics } = metadata;\n            if (cacheTags) {\n                headers[NEXT_CACHE_TAGS_HEADER] = cacheTags;\n            }\n            // Pull any fetch metrics from the render onto the request.\n            ;\n            req.fetchMetrics = fetchMetrics;\n            // we don't throw static to dynamic errors in dev as isSSG\n            // is a best guess in dev since we don't have the prerender pass\n            // to know whether the path is actually static or not\n            if (isSSG && (cacheControl == null ? void 0 : cacheControl.revalidate) === 0 && !routeModule.isDev && !isRoutePPREnabled) {\n                const staticBailoutInfo = metadata.staticBailoutInfo;\n                const err = Object.defineProperty(new Error(`Page changed from static to dynamic at runtime ${resolvedPathname}${(staticBailoutInfo == null ? void 0 : staticBailoutInfo.description) ? `, reason: ${staticBailoutInfo.description}` : ``}` + `\\nsee more here https://nextjs.org/docs/messages/app-static-to-dynamic-error`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E132\",\n                    enumerable: false,\n                    configurable: true\n                });\n                if (staticBailoutInfo == null ? void 0 : staticBailoutInfo.stack) {\n                    const stack = staticBailoutInfo.stack;\n                    err.stack = err.message + stack.substring(stack.indexOf('\\n'));\n                }\n                throw err;\n            }\n            return {\n                value: {\n                    kind: CachedRouteKind.APP_PAGE,\n                    html: result,\n                    headers,\n                    rscData: metadata.flightData,\n                    postponed: metadata.postponed,\n                    status: metadata.statusCode,\n                    segmentData: metadata.segmentData\n                },\n                cacheControl\n            };\n        };\n        const responseGenerator = async ({ hasResolved, previousCacheEntry: previousIncrementalCacheEntry, isRevalidating, span, forceStaticRender = false })=>{\n            const isProduction = routeModule.isDev === false;\n            const didRespond = hasResolved || res.writableEnded;\n            // skip on-demand revalidate if cache is not present and\n            // revalidate-if-generated is set\n            if (isOnDemandRevalidate && revalidateOnlyGenerated && !previousIncrementalCacheEntry && !isMinimalMode) {\n                if (routerServerContext == null ? void 0 : routerServerContext.render404) {\n                    await routerServerContext.render404(req, res);\n                } else {\n                    res.statusCode = 404;\n                    res.end('This page could not be found');\n                }\n                return null;\n            }\n            let fallbackMode;\n            if (prerenderInfo) {\n                fallbackMode = parseFallbackField(prerenderInfo.fallback);\n            }\n            // When serving a HTML bot request, we want to serve a blocking render and\n            // not the prerendered page. This ensures that the correct content is served\n            // to the bot in the head.\n            if (fallbackMode === FallbackMode.PRERENDER && isBot(userAgent)) {\n                if (!isRoutePPREnabled || isHtmlBot) {\n                    fallbackMode = FallbackMode.BLOCKING_STATIC_RENDER;\n                }\n            }\n            if ((previousIncrementalCacheEntry == null ? void 0 : previousIncrementalCacheEntry.isStale) === -1) {\n                isOnDemandRevalidate = true;\n            }\n            // TODO: adapt for PPR\n            // only allow on-demand revalidate for fallback: true/blocking\n            // or for prerendered fallback: false paths\n            if (isOnDemandRevalidate && (fallbackMode !== FallbackMode.NOT_FOUND || previousIncrementalCacheEntry)) {\n                fallbackMode = FallbackMode.BLOCKING_STATIC_RENDER;\n            }\n            if (!isMinimalMode && fallbackMode !== FallbackMode.BLOCKING_STATIC_RENDER && staticPathKey && !didRespond && !isDraftMode && pageIsDynamic && (isProduction || !isPrerendered)) {\n                // if the page has dynamicParams: false and this pathname wasn't\n                // prerendered trigger the no fallback handling\n                if (// In development, fall through to render to handle missing\n                // getStaticPaths.\n                (isProduction || prerenderInfo) && // When fallback isn't present, abort this render so we 404\n                fallbackMode === FallbackMode.NOT_FOUND) {\n                    if (nextConfig.experimental.adapterPath) {\n                        return await render404();\n                    }\n                    throw new NoFallbackError();\n                }\n                // When cacheComponents is enabled, we can use the fallback\n                // response if the request is not a dynamic RSC request because the\n                // RSC data when this feature flag is enabled does not contain any\n                // param references. Without this feature flag enabled, the RSC data\n                // contains param references, and therefore we can't use the fallback.\n                if (isRoutePPREnabled && (nextConfig.cacheComponents ? !isDynamicRSCRequest : !isRSCRequest)) {\n                    const cacheKey = isProduction && typeof (prerenderInfo == null ? void 0 : prerenderInfo.fallback) === 'string' ? prerenderInfo.fallback : normalizedSrcPage;\n                    const fallbackRouteParams = // If we're in production and we have fallback route params, then we\n                    // can use the manifest fallback route params.\n                    isProduction && (prerenderInfo == null ? void 0 : prerenderInfo.fallbackRouteParams) ? createOpaqueFallbackRouteParams(prerenderInfo.fallbackRouteParams) : // have to manually generate the fallback route params.\n                    isDebugFallbackShell ? getFallbackRouteParams(normalizedSrcPage, routeModule) : null;\n                    // We use the response cache here to handle the revalidation and\n                    // management of the fallback shell.\n                    const fallbackResponse = await routeModule.handleResponse({\n                        cacheKey,\n                        req,\n                        nextConfig,\n                        routeKind: RouteKind.APP_PAGE,\n                        isFallback: true,\n                        prerenderManifest,\n                        isRoutePPREnabled,\n                        responseGenerator: async ()=>doRender({\n                                span,\n                                // We pass `undefined` as rendering a fallback isn't resumed\n                                // here.\n                                postponed: undefined,\n                                fallbackRouteParams,\n                                forceStaticRender: false\n                            }),\n                        waitUntil: ctx.waitUntil,\n                        isMinimalMode\n                    });\n                    // If the fallback response was set to null, then we should return null.\n                    if (fallbackResponse === null) return null;\n                    // Otherwise, if we did get a fallback response, we should return it.\n                    if (fallbackResponse) {\n                        // Remove the cache control from the response to prevent it from being\n                        // used in the surrounding cache.\n                        delete fallbackResponse.cacheControl;\n                        return fallbackResponse;\n                    }\n                }\n            }\n            // Only requests that aren't revalidating can be resumed. If we have the\n            // minimal postponed data, then we should resume the render with it.\n            let postponed = !isOnDemandRevalidate && !isRevalidating && minimalPostponed ? minimalPostponed : undefined;\n            // If this is a dynamic RSC request or a server action request, we should\n            // use the postponed data from the static render (if available). This\n            // ensures that we can utilize the resume data cache (RDC) from the static\n            // render to ensure that the data is consistent between the static and\n            // dynamic renders (for navigations) or when re-rendering after a server\n            // action.\n            if (// Only enable RDC for Navigations if the feature is enabled.\n            supportsRDCForNavigations && process.env.NEXT_RUNTIME !== 'edge' && !isMinimalMode && incrementalCache && // Include both dynamic RSC requests (navigations) and server actions\n            (isDynamicRSCRequest || isPossibleServerAction) && // We don't typically trigger an on-demand revalidation for dynamic RSC\n            // requests, as we're typically revalidating the page in the background\n            // instead. However, if the cache entry is stale, we should trigger a\n            // background revalidation on dynamic RSC requests. This prevents us\n            // from entering an infinite loop of revalidations.\n            !forceStaticRender) {\n                const incrementalCacheEntry = await incrementalCache.get(resolvedPathname, {\n                    kind: IncrementalCacheKind.APP_PAGE,\n                    isRoutePPREnabled: true,\n                    isFallback: false\n                });\n                // If the cache entry is found, we should use the postponed data from\n                // the cache.\n                if (incrementalCacheEntry && incrementalCacheEntry.value && incrementalCacheEntry.value.kind === CachedRouteKind.APP_PAGE) {\n                    // CRITICAL: we're assigning the postponed data from the cache entry\n                    // here as we're using the RDC to resume the render.\n                    postponed = incrementalCacheEntry.value.postponed;\n                    // If the cache entry is stale, we should trigger a background\n                    // revalidation so that subsequent requests will get a fresh response.\n                    if (incrementalCacheEntry && // We want to trigger this flow if the cache entry is stale and if\n                    // the requested revalidation flow is either foreground or\n                    // background.\n                    (incrementalCacheEntry.isStale === -1 || incrementalCacheEntry.isStale === true)) {\n                        // We want to schedule this on the next tick to ensure that the\n                        // render is not blocked on it.\n                        scheduleOnNextTick(async ()=>{\n                            const responseCache = routeModule.getResponseCache(req);\n                            try {\n                                await responseCache.revalidate(resolvedPathname, incrementalCache, isRoutePPREnabled, false, (c)=>responseGenerator({\n                                        ...c,\n                                        // CRITICAL: we need to set this to true as we're\n                                        // revalidating in the background and typically this dynamic\n                                        // RSC request is not treated as static.\n                                        forceStaticRender: true\n                                    }), // CRITICAL: we need to pass null here because passing the\n                                // previous cache entry here (which is stale) will switch on\n                                // isOnDemandRevalidate and break the prerendering.\n                                null, hasResolved, ctx.waitUntil);\n                            } catch (err) {\n                                console.error('Error revalidating the page in the background', err);\n                            }\n                        });\n                    }\n                }\n            }\n            // When we're in minimal mode, if we're trying to debug the static shell,\n            // we should just return nothing instead of resuming the dynamic render.\n            if ((isDebugStaticShell || isDebugDynamicAccesses) && typeof postponed !== 'undefined') {\n                return {\n                    cacheControl: {\n                        revalidate: 1,\n                        expire: undefined\n                    },\n                    value: {\n                        kind: CachedRouteKind.PAGES,\n                        html: RenderResult.EMPTY,\n                        pageData: {},\n                        headers: undefined,\n                        status: undefined\n                    }\n                };\n            }\n            const fallbackRouteParams = // If we're in production and we have fallback route params, then we\n            // can use the manifest fallback route params if we need to render the\n            // fallback shell.\n            isProduction && (prerenderInfo == null ? void 0 : prerenderInfo.fallbackRouteParams) && getRequestMeta(req, 'renderFallbackShell') ? createOpaqueFallbackRouteParams(prerenderInfo.fallbackRouteParams) : // manually generate the fallback route params.\n            isDebugFallbackShell ? getFallbackRouteParams(normalizedSrcPage, routeModule) : null;\n            // Perform the render.\n            return doRender({\n                span,\n                postponed,\n                fallbackRouteParams,\n                forceStaticRender\n            });\n        };\n        const handleResponse = async (span)=>{\n            var _cacheEntry_value, _cachedData_headers;\n            const cacheEntry = await routeModule.handleResponse({\n                cacheKey: ssgCacheKey,\n                responseGenerator: (c)=>responseGenerator({\n                        span,\n                        ...c\n                    }),\n                routeKind: RouteKind.APP_PAGE,\n                isOnDemandRevalidate,\n                isRoutePPREnabled,\n                req,\n                nextConfig,\n                prerenderManifest,\n                waitUntil: ctx.waitUntil,\n                isMinimalMode\n            });\n            if (isDraftMode) {\n                res.setHeader('Cache-Control', 'private, no-cache, no-store, max-age=0, must-revalidate');\n            }\n            // In dev, we should not cache pages for any reason.\n            if (routeModule.isDev) {\n                res.setHeader('Cache-Control', nextConfig.experimental.devCacheControlNoCache ? 'no-cache, must-revalidate' : 'no-store, must-revalidate');\n            }\n            if (!cacheEntry) {\n                if (ssgCacheKey) {\n                    // A cache entry might not be generated if a response is written\n                    // in `getInitialProps` or `getServerSideProps`, but those shouldn't\n                    // have a cache key. If we do have a cache key but we don't end up\n                    // with a cache entry, then either Next.js or the application has a\n                    // bug that needs fixing.\n                    throw Object.defineProperty(new Error('invariant: cache entry required but not generated'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E62\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                return null;\n            }\n            if (((_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) !== CachedRouteKind.APP_PAGE) {\n                var _cacheEntry_value1;\n                throw Object.defineProperty(new Error(`Invariant app-page handler received invalid cache entry ${(_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E707\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            const didPostpone = typeof cacheEntry.value.postponed === 'string';\n            // Set the build ID header for RSC navigation requests when deploymentId is configured. This\n            // corresponds with maybeAppendBuildIdToRSCPayload in app-render.tsx which omits the build ID\n            // from the RSC payload when deploymentId is set (relying on this header instead). Server\n            // actions are excluded because the client doesn't check the build ID for action responses.\n            // For static prerenders served from CDN, routes-manifest.json adds a header.\n            if (isRSCRequest && !isPossibleServerAction && deploymentId) {\n                res.setHeader(NEXT_NAV_DEPLOYMENT_ID_HEADER, deploymentId);\n            }\n            if (isSSG && // We don't want to send a cache header for requests that contain dynamic\n            // data. If this is a Dynamic RSC request or wasn't a Prefetch RSC\n            // request, then we should set the cache header.\n            !isDynamicRSCRequest && (!didPostpone || isPrefetchRSCRequest)) {\n                if (!isMinimalMode) {\n                    // set x-nextjs-cache header to match the header\n                    // we set for the image-optimizer\n                    res.setHeader('x-nextjs-cache', isOnDemandRevalidate ? 'REVALIDATED' : cacheEntry.isMiss ? 'MISS' : cacheEntry.isStale ? 'STALE' : 'HIT');\n                }\n                // Set a header used by the client router to signal the response is static\n                // and should respect the `static` cache staleTime value.\n                res.setHeader(NEXT_IS_PRERENDER_HEADER, '1');\n            }\n            const { value: cachedData } = cacheEntry;\n            // Coerce the cache control parameter from the render.\n            let cacheControl;\n            // If this is a resume request in minimal mode it is streamed with dynamic\n            // content and should not be cached.\n            if (minimalPostponed) {\n                cacheControl = {\n                    revalidate: 0,\n                    expire: undefined\n                };\n            } else if (isDynamicRSCRequest) {\n                cacheControl = {\n                    revalidate: 0,\n                    expire: undefined\n                };\n            } else if (!routeModule.isDev) {\n                // If this is a preview mode request, we shouldn't cache it\n                if (isDraftMode) {\n                    cacheControl = {\n                        revalidate: 0,\n                        expire: undefined\n                    };\n                } else if (!isSSG) {\n                    if (!res.getHeader('Cache-Control')) {\n                        cacheControl = {\n                            revalidate: 0,\n                            expire: undefined\n                        };\n                    }\n                } else if (cacheEntry.cacheControl) {\n                    // If the cache entry has a cache control with a revalidate value that's\n                    // a number, use it.\n                    if (typeof cacheEntry.cacheControl.revalidate === 'number') {\n                        var _cacheEntry_cacheControl;\n                        if (cacheEntry.cacheControl.revalidate < 1) {\n                            throw Object.defineProperty(new Error(`Invalid revalidate configuration provided: ${cacheEntry.cacheControl.revalidate} < 1`), \"__NEXT_ERROR_CODE\", {\n                                value: \"E22\",\n                                enumerable: false,\n                                configurable: true\n                            });\n                        }\n                        cacheControl = {\n                            revalidate: cacheEntry.cacheControl.revalidate,\n                            expire: ((_cacheEntry_cacheControl = cacheEntry.cacheControl) == null ? void 0 : _cacheEntry_cacheControl.expire) ?? nextConfig.expireTime\n                        };\n                    } else {\n                        cacheControl = {\n                            revalidate: CACHE_ONE_YEAR_SECONDS,\n                            expire: undefined\n                        };\n                    }\n                }\n            }\n            cacheEntry.cacheControl = cacheControl;\n            if (typeof segmentPrefetchHeader === 'string' && (cachedData == null ? void 0 : cachedData.kind) === CachedRouteKind.APP_PAGE && cachedData.segmentData) {\n                var _cachedData_headers1;\n                // This is a prefetch request issued by the client Segment Cache. These\n                // should never reach the application layer (lambda). We should either\n                // respond from the cache (HIT) or respond with 204 No Content (MISS).\n                // Set a header to indicate that PPR is enabled for this route. This\n                // lets the client distinguish between a regular cache miss and a cache\n                // miss due to PPR being disabled. In other contexts this header is used\n                // to indicate that the response contains dynamic data, but here we're\n                // only using it to indicate that the feature is enabled  the segment\n                // response itself contains whether the data is dynamic.\n                res.setHeader(NEXT_DID_POSTPONE_HEADER, '2');\n                // Add the cache tags header to the response if it exists and we're in\n                // minimal mode while rendering a static page.\n                const tags = (_cachedData_headers1 = cachedData.headers) == null ? void 0 : _cachedData_headers1[NEXT_CACHE_TAGS_HEADER];\n                if (isMinimalMode && isSSG && tags && typeof tags === 'string') {\n                    res.setHeader(NEXT_CACHE_TAGS_HEADER, tags);\n                }\n                const matchedSegment = cachedData.segmentData.get(segmentPrefetchHeader);\n                if (matchedSegment !== undefined) {\n                    // Cache hit\n                    return sendRenderResult({\n                        req,\n                        res,\n                        generateEtags: nextConfig.generateEtags,\n                        poweredByHeader: nextConfig.poweredByHeader,\n                        result: RenderResult.fromStatic(matchedSegment, RSC_CONTENT_TYPE_HEADER),\n                        cacheControl: cacheEntry.cacheControl\n                    });\n                }\n                // Cache miss. Either a cache entry for this route has not been generated\n                // (which technically should not be possible when PPR is enabled, because\n                // at a minimum there should always be a fallback entry) or there's no\n                // match for the requested segment. Respond with a 204 No Content. We\n                // don't bother to respond with 404, because these requests are only\n                // issued as part of a prefetch.\n                res.statusCode = 204;\n                return sendRenderResult({\n                    req,\n                    res,\n                    generateEtags: nextConfig.generateEtags,\n                    poweredByHeader: nextConfig.poweredByHeader,\n                    result: RenderResult.EMPTY,\n                    cacheControl: cacheEntry.cacheControl\n                });\n            }\n            // If there's a callback for `onCacheEntry`, call it with the cache entry\n            // and the revalidate options. If we support RDC for Navigations, we\n            // prefer the `onCacheEntryV2` callback. Once RDC for Navigations is the\n            // default, we can remove the fallback to `onCacheEntry` as\n            // `onCacheEntryV2` is now fully supported.\n            const onCacheEntry = supportsRDCForNavigations ? getRequestMeta(req, 'onCacheEntryV2') ?? getRequestMeta(req, 'onCacheEntry') : getRequestMeta(req, 'onCacheEntry');\n            if (onCacheEntry) {\n                const finished = await onCacheEntry(cacheEntry, {\n                    url: getRequestMeta(req, 'initURL') ?? req.url\n                });\n                if (finished) return null;\n            }\n            if (cachedData.headers) {\n                const headers = {\n                    ...cachedData.headers\n                };\n                if (!isMinimalMode || !isSSG) {\n                    delete headers[NEXT_CACHE_TAGS_HEADER];\n                }\n                for (let [key, value] of Object.entries(headers)){\n                    if (typeof value === 'undefined') continue;\n                    if (Array.isArray(value)) {\n                        for (const v of value){\n                            res.appendHeader(key, v);\n                        }\n                    } else if (typeof value === 'number') {\n                        value = value.toString();\n                        res.appendHeader(key, value);\n                    } else {\n                        res.appendHeader(key, value);\n                    }\n                }\n            }\n            // Add the cache tags header to the response if it exists and we're in\n            // minimal mode while rendering a static page.\n            const tags = (_cachedData_headers = cachedData.headers) == null ? void 0 : _cachedData_headers[NEXT_CACHE_TAGS_HEADER];\n            if (isMinimalMode && isSSG && tags && typeof tags === 'string') {\n                res.setHeader(NEXT_CACHE_TAGS_HEADER, tags);\n            }\n            // If the request is a data request, then we shouldn't set the status code\n            // from the response because it should always be 200. This should be gated\n            // behind the experimental PPR flag.\n            if (cachedData.status && (!isRSCRequest || !isRoutePPREnabled)) {\n                res.statusCode = cachedData.status;\n            }\n            // Redirect information is encoded in RSC payload, so we don't need to use redirect status codes\n            if (!isMinimalMode && cachedData.status && RedirectStatusCode[cachedData.status] && isRSCRequest) {\n                res.statusCode = 200;\n            }\n            // Mark that the request did postpone.\n            if (didPostpone && !isDynamicRSCRequest) {\n                res.setHeader(NEXT_DID_POSTPONE_HEADER, '1');\n            }\n            // we don't go through this block when preview mode is true\n            // as preview mode is a dynamic request (bypasses cache) and doesn't\n            // generate both HTML and payloads in the same request so continue to just\n            // return the generated payload\n            if (isRSCRequest && !isDraftMode) {\n                // If this is a dynamic RSC request, then stream the response.\n                if (typeof cachedData.rscData === 'undefined') {\n                    // If the response is not an RSC response, then we can't serve it.\n                    if (cachedData.html.contentType !== RSC_CONTENT_TYPE_HEADER) {\n                        if (nextConfig.cacheComponents) {\n                            res.statusCode = 404;\n                            return sendRenderResult({\n                                req,\n                                res,\n                                generateEtags: nextConfig.generateEtags,\n                                poweredByHeader: nextConfig.poweredByHeader,\n                                result: RenderResult.EMPTY,\n                                cacheControl: cacheEntry.cacheControl\n                            });\n                        } else {\n                            // Otherwise this case is not expected.\n                            throw Object.defineProperty(new InvariantError(`Expected RSC response, got ${cachedData.html.contentType}`), \"__NEXT_ERROR_CODE\", {\n                                value: \"E789\",\n                                enumerable: false,\n                                configurable: true\n                            });\n                        }\n                    }\n                    return sendRenderResult({\n                        req,\n                        res,\n                        generateEtags: nextConfig.generateEtags,\n                        poweredByHeader: nextConfig.poweredByHeader,\n                        result: cachedData.html,\n                        cacheControl: cacheEntry.cacheControl\n                    });\n                }\n                // As this isn't a prefetch request, we should serve the static flight\n                // data.\n                return sendRenderResult({\n                    req,\n                    res,\n                    generateEtags: nextConfig.generateEtags,\n                    poweredByHeader: nextConfig.poweredByHeader,\n                    result: RenderResult.fromStatic(cachedData.rscData, RSC_CONTENT_TYPE_HEADER),\n                    cacheControl: cacheEntry.cacheControl\n                });\n            }\n            // This is a request for HTML data.\n            const body = cachedData.html;\n            // If there's no postponed state, we should just serve the HTML. This\n            // should also be the case for a resume request because it's completed\n            // as a server render (rather than a static render).\n            if (!didPostpone || isMinimalMode || isRSCRequest) {\n                // If we're in test mode, we should add a sentinel chunk to the response\n                // that's between the static and dynamic parts so we can compare the\n                // chunks and add assertions.\n                if (process.env.__NEXT_TEST_MODE && isMinimalMode && isRoutePPREnabled && body.contentType === HTML_CONTENT_TYPE_HEADER) {\n                    // As we're in minimal mode, the static part would have already been\n                    // streamed first. The only part that this streams is the dynamic part\n                    // so we should FIRST stream the sentinel and THEN the dynamic part.\n                    body.unshift(createPPRBoundarySentinel());\n                }\n                return sendRenderResult({\n                    req,\n                    res,\n                    generateEtags: nextConfig.generateEtags,\n                    poweredByHeader: nextConfig.poweredByHeader,\n                    result: body,\n                    cacheControl: cacheEntry.cacheControl\n                });\n            }\n            // If we're debugging the static shell or the dynamic API accesses, we\n            // should just serve the HTML without resuming the render. The returned\n            // HTML will be the static shell so all the Dynamic API's will be used\n            // during static generation.\n            if (isDebugStaticShell || isDebugDynamicAccesses) {\n                // Since we're not resuming the render, we need to at least add the\n                // closing body and html tags to create valid HTML.\n                body.push(new ReadableStream({\n                    start (controller) {\n                        controller.enqueue(ENCODED_TAGS.CLOSED.BODY_AND_HTML);\n                        controller.close();\n                    }\n                }));\n                return sendRenderResult({\n                    req,\n                    res,\n                    generateEtags: nextConfig.generateEtags,\n                    poweredByHeader: nextConfig.poweredByHeader,\n                    result: body,\n                    cacheControl: {\n                        revalidate: 0,\n                        expire: undefined\n                    }\n                });\n            }\n            // If we're in test mode, we should add a sentinel chunk to the response\n            // that's between the static and dynamic parts so we can compare the\n            // chunks and add assertions.\n            if (process.env.__NEXT_TEST_MODE) {\n                body.push(createPPRBoundarySentinel());\n            }\n            // This request has postponed, so let's create a new transformer that the\n            // dynamic data can pipe to that will attach the dynamic data to the end\n            // of the response.\n            const transformer = new TransformStream();\n            body.push(transformer.readable);\n            // Perform the render again, but this time, provide the postponed state.\n            // We don't await because we want the result to start streaming now, and\n            // we've already chained the transformer's readable to the render result.\n            doRender({\n                span,\n                postponed: cachedData.postponed,\n                // This is a resume render, not a fallback render, so we don't need to\n                // set this.\n                fallbackRouteParams: null,\n                forceStaticRender: false\n            }).then(async (result)=>{\n                var _result_value;\n                if (!result) {\n                    throw Object.defineProperty(new Error('Invariant: expected a result to be returned'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E463\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                if (((_result_value = result.value) == null ? void 0 : _result_value.kind) !== CachedRouteKind.APP_PAGE) {\n                    var _result_value1;\n                    throw Object.defineProperty(new Error(`Invariant: expected a page response, got ${(_result_value1 = result.value) == null ? void 0 : _result_value1.kind}`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E305\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                // Pipe the resume result to the transformer.\n                await result.value.html.pipeTo(transformer.writable);\n            }).catch((err)=>{\n                // An error occurred during piping or preparing the render, abort\n                // the transformers writer so we can terminate the stream.\n                transformer.writable.abort(err).catch((e)=>{\n                    console.error(\"couldn't abort transformer\", e);\n                });\n            });\n            return sendRenderResult({\n                req,\n                res,\n                generateEtags: nextConfig.generateEtags,\n                poweredByHeader: nextConfig.poweredByHeader,\n                result: body,\n                // We don't want to cache the response if it has postponed data because\n                // the response being sent to the client it's dynamic parts are streamed\n                // to the client on the same request.\n                cacheControl: {\n                    revalidate: 0,\n                    expire: undefined\n                }\n            });\n        };\n        // TODO: activeSpan code path is for when wrapped by\n        // next-server can be removed when this is no longer used\n        if (activeSpan) {\n            await handleResponse(activeSpan);\n        } else {\n            return await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(BaseServerSpan.handleRequest, {\n                    spanName: `${method} ${srcPage}`,\n                    kind: SpanKind.SERVER,\n                    attributes: {\n                        'http.method': method,\n                        'http.target': req.url\n                    }\n                }, handleResponse));\n        }\n    } catch (err) {\n        if (!(err instanceof NoFallbackError)) {\n            const silenceLog = false;\n            await routeModule.onRequestError(req, err, {\n                routerKind: 'App Router',\n                routePath: srcPage,\n                routeType: 'render',\n                revalidateReason: getRevalidateReason({\n                    isStaticGeneration: isSSG,\n                    isOnDemandRevalidate\n                })\n            }, silenceLog, routerServerContext);\n        }\n        // rethrow so that we can handle serving error page\n        throw err;\n    }\n}\n// TODO: omit this from production builds, only test builds should include it\n/**\n * Creates a readable stream that emits a PPR boundary sentinel.\n *\n * @returns A readable stream that emits a PPR boundary sentinel.\n */ function createPPRBoundarySentinel() {\n    return new ReadableStream({\n        start (controller) {\n            controller.enqueue(new TextEncoder().encode('<!-- PPR_BOUNDARY_SENTINEL -->'));\n            controller.close();\n        }\n    });\n}\n\n//# sourceMappingURL=app-page.js.map\n"],"names":["layout #0","not-found #1","forbidden #2","unauthorized #3","global-error #4","page #5","tree","metadata","__next_app_require__","__turbopack_context__","r","bind","__next_app_load_chunk__","l","__next_app__","require","loadChunk","routeModule","definition","kind","APP_PAGE","page","pathname","bundlePath","filename","appPaths","userland","loaderTree","distDir","relativeProjectDir","handler","req","res","ctx","_this","_prerenderManifest_routes_resolvedPathname","requestMeta","isDev","process","hrtime","bigint","isMinimalMode","Boolean","srcPage","replace","multiZoneDraftMode","prepareResult","prepare","statusCode","end","waitUntil","call","Promise","resolve","buildId","query","params","pageIsDynamic","buildManifest","nextFontManifest","reactLoadableManifest","serverActionsManifest","clientReferenceManifest","subresourceIntegrityManifest","prerenderManifest","isDraftMode","resolvedPathname","revalidateOnlyGenerated","routerServerContext","nextConfig","parsedUrl","interceptionRoutePatterns","deploymentId","normalizedSrcPage","isOnDemandRevalidate","prerenderInfo","experimental","ppr","cacheComponents","match","isPrerendered","routes","userAgent","headers","botType","isHtmlBot","isPrefetchRSCRequest","isRSCRequest","isPossibleServerAction","couldSupportPPR","resumeStateLengthHeader","stateLength","parseInt","maxPostponedStateSize","maxPostponedStateSizeBytes","isNaN","_nextConfig_experimental_serverActions","undefined","defaultActionBodySizeLimit","actionBodySizeLimit","serverActions","bodySizeLimit","actionBodySizeLimitBytes","parse","maxTotalBodySize","bodyChunks","size","chunk","buffer","Buffer","isBuffer","from","byteLength","push","fullBody","concat","length","postponedState","subarray","toString","actionBody","Object","defineProperty","Error","value","enumerable","configurable","method","body","postponed","hasDebugStaticShellQuery","__nextppronly","hasDebugFallbackShellQuery","exposeTestingApi","exposeTestingApiInProductionBuild","isInstantNavigationTest","cookie","includes","isRoutePPREnabled","dynamicRoutes","renderingMode","experimentalTestProxy","isDebugStaticShell","isDebugDynamicAccesses","isDebugFallbackShell","minimalPostponed","staticPrefetchDataRoute","prefetchDataRoute","isDynamicRSCRequest","segmentPrefetchHeader","serveStreamingMetadata","htmlLimitedBots","isSSG","supportsRDCForNavigations","supportsDynamicResponse","shouldWaitOnAllReady","ssgCacheKey","staticPathKey","ComponentMod","imported module 22922","tracer","activeSpan","getActiveScopeSpan","render404","varyHeader","getVaryHeader","setHeader","invokeRouteModule","span","context","nextReq","nextRes","render","finally","setAttributes","rootSpanAttributes","getRootSpanAttributes","get","handleRequest","console","warn","route","name","updateName","incrementalCache","getIncrementalCache","resetRequestCache","globalThis","__incrementalCache","doRender","fallbackRouteParams","forceStaticRender","sharedContext","serverComponentsHmrCache","renderOpts","App","Document","pageConfig","Component","setCacheStatus","setIsrStatus","setReactDebugChannel","sendErrorsToBrowser","dir","join","cwd","assetPrefix","nextConfigOutput","output","crossOrigin","trailingSlash","images","previewProps","preview","enableTainting","taint","reactMaxHeadersLength","cacheLifeProfiles","cacheLife","basePath","logServerFunctions","logging","serverFunctions","isBuildTimePrerendering","isStaticGeneration","expireTime","staleTimes","dynamicOnHover","optimisticRouting","inlineCss","authInterrupts","clientTraceMetadata","clientParamParsingOrigins","onClose","cb","on","onAfterTaskError","onInstrumentationRequestError","error","_request","errorContext","silenceLog","onRequestError","err","dev","result","cacheControl","fetchTags","cacheTags","fetchMetrics","revalidate","staticBailoutInfo","description","stack","message","substring","indexOf","html","rscData","flightData","status","segmentData","responseGenerator","hasResolved","previousCacheEntry","previousIncrementalCacheEntry","isRevalidating","isProduction","didRespond","writableEnded","fallbackMode","fallback","PRERENDER","BLOCKING_STATIC_RENDER","isStale","NOT_FOUND","adapterPath","cacheKey","fallbackResponse","handleResponse","routeKind","isFallback","incrementalCacheEntry","responseCache","getResponseCache","c","expire","PAGES","EMPTY","pageData","_cacheEntry_value","_cachedData_headers","cacheEntry","devCacheControlNoCache","_cacheEntry_value1","didPostpone","isMiss","cachedData","getHeader","_cacheEntry_cacheControl","_cachedData_headers1","tags","matchedSegment","generateEtags","poweredByHeader","fromStatic","onCacheEntry","finished","url","key","entries","Array","isArray","v","appendHeader","contentType","ReadableStream","start","controller","enqueue","CLOSED","BODY_AND_HTML","close","transformer","TransformStream","readable","then","_result_value","_result_value1","pipeTo","writable","catch","abort","e","withPropagatedContext","trace","spanName","SERVER","attributes","routerKind","routePath","routeType","revalidateReason","createPPRBoundarySentinel","TextEncoder","encode"],"mappings":"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","ignoreList":[0]}